package lanat.parsing.errors;

import lanat.ArgumentParser;
import lanat.Command;
import lanat.parsing.Token;
import lanat.parsing.errors.formatGenerators.BaseErrorFormatter;
import lanat.utils.UtlReflection;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;

/**
 * Handles all errors generated by the parser and tokenizer.
 */
public class ErrorsCollector {
	private final @NotNull ArgumentParser argumentParser;
	private final @NotNull List<@NotNull Token> fullTokenList;
	private final @NotNull Hashtable<Command, List<Error<?>>> errors = new Hashtable<>();
	private static @NotNull Class<? extends BaseErrorFormatter> errorFormatterClass = BaseErrorFormatter.class;

	public ErrorsCollector(@NotNull ArgumentParser argumentParser) {
		this.argumentParser = argumentParser;
		this.fullTokenList = argumentParser.getFullTokenList();
	}

	public void collect(@NotNull Command command) {
		this.errors.put(command, new ArrayList<>() {{
			this.addAll(command.getTokenizer().getErrorsUnderDisplayLevel());
			this.addAll(command.getParser().getErrorsUnderDisplayLevel());
			command.getArguments().forEach(arg -> this.addAll(arg.getErrorsUnderDisplayLevel()));
			this.addAll(command.getErrorsUnderDisplayLevel());
		}});
	}

	public void collectAllInTree() {
		this.argumentParser.getTokenizer().getTokenizedCommands().forEach(this::collect);
	}

	public List<String> handleErrors() {
		// reuse the same context for all errors of the same type. only create a new one when needed.
		final var errorMessages = new ArrayList<String>();

		for (var pair : this.errors.entrySet()) {
			final var command = pair.getKey();
			final var errors = pair.getValue();

			var x = UtlReflection.instantiate(
				ErrorsCollector.errorFormatterClass, new TokenizeContext(command)
			);

			var y = UtlReflection.instantiate(
				ErrorsCollector.errorFormatterClass, new ParseContext(this.fullTokenList, command)
			);

			for (var error : errors) {
				final var errorFormatter = new ErrorFormattingContext();

				if (error instanceof Error.TokenizeError tokenizeError) {
					tokenizeError.handle(errorFormatter, (TokenizeContext)x.getCurrentErrorContext());
					errorMessages.add(x.generateInternal(error, errorFormatter));
				} else if (error instanceof Error.ParseError parseError) {
					parseError.handle(errorFormatter, (ParseContext)y.getCurrentErrorContext());
					errorMessages.add(y.generateInternal(error, errorFormatter));
				}
			}
		}

		return errorMessages;
	}
}