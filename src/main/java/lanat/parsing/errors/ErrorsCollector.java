package lanat.parsing.errors;

import lanat.ArgumentParser;
import lanat.Command;
import lanat.parsing.Token;
import lanat.parsing.errors.formatGenerators.BaseErrorFormatter;
import lanat.parsing.errors.formatGenerators.PrettyErrorFormatter;
import lanat.utils.Pair;
import lanat.utils.UtlReflection;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Hashtable;
import java.util.List;
import java.util.function.Supplier;

/**
 * Handles all errors generated by the parser and tokenizer.
 */
public class ErrorsCollector {
	private final @NotNull ArgumentParser argumentParser;
	private final @NotNull List<@NotNull Token> fullTokenList;
	private final @NotNull Hashtable<Command, List<Error<?>>> errors = new Hashtable<>();
	public static @NotNull Class<? extends BaseErrorFormatter> errorFormatterClass = PrettyErrorFormatter.class;

	private BaseErrorFormatter tokenizeFormatter, parseFormatter;

	public ErrorsCollector(@NotNull ArgumentParser argumentParser) {
		this.argumentParser = argumentParser;
		this.fullTokenList = argumentParser.getFullTokenList();
	}

	public void collect(@NotNull Command command) {
		this.errors.put(command, new ArrayList<>() {{
			this.addAll(command.getTokenizer().getErrorsUnderDisplayLevel());
			this.addAll(command.getParser().getErrorsUnderDisplayLevel());
			command.getArguments().forEach(arg -> this.addAll(arg.getErrorsUnderDisplayLevel()));
			this.addAll(command.getErrorsUnderDisplayLevel());
		}});
	}

	public void collectAllInTree() {
		this.argumentParser.getTokenizer().getTokenizedCommands().forEach(this::collect);
	}

	public List<String> handleErrors() {
		final var errorMessages = new ArrayList<Pair<String, Integer>>();

		for (var pair : this.errors.entrySet()) {
			final var command = pair.getKey();
			final var errors = pair.getValue();

			for (var error : errors) {
				final var errorFormattingCtx = new ErrorFormattingContext();
				BaseErrorFormatter formatter = null;

				if (error instanceof Error.TokenizeError tokenizeError) {
					formatter = this.getTokenizeFormatter(command);
					tokenizeError.handle(errorFormattingCtx, (TokenizeContext)formatter.getCurrentErrorContext());
				} else if (error instanceof Error.ParseError parseError) {
					formatter = this.getParseFormatter(command);
					parseError.handle(errorFormattingCtx, (ParseContext)formatter.getCurrentErrorContext());
				}

				assert formatter != null; // impossible because Error is sealed

				errorMessages.add(new Pair<>(
					formatter.generateInternal(error, errorFormattingCtx),
					0
				));
			}
		}

		return errorMessages.stream()
			.sorted(Comparator.comparingInt(Pair::second))
			.map(Pair::first)
			.toList();
	}

	private @NotNull BaseErrorFormatter getTokenizeFormatter(@NotNull Command cmd) {
		if (this.tokenizeFormatter == null || this.tokenizeFormatter.getCurrentErrorContext().getCommand() != cmd)
			this.tokenizeFormatter = getFormatter(() -> new TokenizeContext(cmd));

		return this.tokenizeFormatter;
	}

	private @NotNull BaseErrorFormatter getParseFormatter(@NotNull Command cmd) {
		if (this.parseFormatter == null || this.parseFormatter.getCurrentErrorContext().getCommand() != cmd)
			this.parseFormatter = getFormatter(() -> new ParseContext(this.fullTokenList, cmd));

		return this.parseFormatter;
	}

	private static @NotNull BaseErrorFormatter getFormatter(@NotNull Supplier<? extends BaseContext> ctx) {
		return UtlReflection.instantiate(
			ErrorsCollector.errorFormatterClass,
			List.of(BaseContext.class),
			List.of(ctx.get())
		);
	}
}