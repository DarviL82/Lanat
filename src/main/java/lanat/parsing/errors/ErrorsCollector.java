package lanat.parsing.errors;

import lanat.Command;
import lanat.parsing.Token;
import lanat.utils.Pair;
import lanat.utils.UtlReflection;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Hashtable;
import java.util.List;
import java.util.function.Supplier;

/**
 * Handles all errors generated by the parser and tokenizer.
 */
public class ErrorsCollector {
	private final @NotNull List<@NotNull Token> fullTokenList;
	private final @NotNull String fullInput;
	private final @NotNull Hashtable<Command, List<Error<?>>> errors = new Hashtable<>();

	private ErrorFormatter tokenizeFormatter, parseFormatter;

	public ErrorsCollector(@NotNull List<@NotNull Token> fullTokenList, @NotNull String fullInputString) {
		this.fullTokenList = fullTokenList;
		this.fullInput = fullInputString;
	}

	public void collect(@NotNull Command command) {
		this.errors.put(command, new ArrayList<>() {{
			this.addAll(command.getTokenizer().getErrorsUnderDisplayLevel());
			this.addAll(command.getParser().getErrorsUnderDisplayLevel());
			command.getArguments().forEach(arg -> this.addAll(arg.getErrorsUnderDisplayLevel()));
			this.addAll(command.getErrorsUnderDisplayLevel());
		}});
	}

	public List<String> handleErrors() {
		final var errorMessages = new ArrayList<Pair<String, Integer>>();

		for (var pair : this.errors.entrySet()) {
			final var command = pair.getKey();
			final var errors = pair.getValue();

			for (var error : errors) {
				final var errorFormattingCtx = new ErrorFormattingContext();
				ErrorFormatter formatter = null;

				if (error instanceof Error.TokenizeError tokenizeError) {
					formatter = this.getTokenizeFormatter(command);
					tokenizeError.handle(errorFormattingCtx, (TokenizeContext)formatter.getCurrentErrorContext());
				} else if (error instanceof Error.ParseError parseError) {
					formatter = this.getParseFormatter(command);
					parseError.handle(errorFormattingCtx, (ParseContext)formatter.getCurrentErrorContext());
				}

				assert formatter != null; // impossible because Error is sealed

				errorMessages.add(new Pair<>(
					formatter.generateInternal(error, errorFormattingCtx),
					formatter.getHighlightOptions()
						.map(v -> v.range().start())
						.orElse(0)
				));
			}
		}

		return errorMessages.stream()
			.sorted(Comparator.comparingInt(Pair::second))
			.map(Pair::first)
			.toList();
	}

	private @NotNull ErrorFormatter getTokenizeFormatter(@NotNull Command cmd) {
		if (this.tokenizeFormatter == null || this.tokenizeFormatter.getCurrentErrorContext().getCommand() != cmd)
			this.tokenizeFormatter = getFormatter(() -> new TokenizeContext(cmd, this.fullInput));

		return this.tokenizeFormatter;
	}

	private @NotNull ErrorFormatter getParseFormatter(@NotNull Command cmd) {
		if (this.parseFormatter == null || this.parseFormatter.getCurrentErrorContext().getCommand() != cmd)
			this.parseFormatter = getFormatter(() -> new ParseContext(cmd, this.fullTokenList));

		return this.parseFormatter;
	}

	private static @NotNull ErrorFormatter getFormatter(@NotNull Supplier<? extends BaseContext> ctx) {
		return UtlReflection.instantiate(
			ErrorFormatter.errorFormatterClass,
			List.of(BaseContext.class),
			List.of(ctx.get())
		);
	}
}